[
  {
    "path": "posts/2022-06-10-many-small-models-the-secret-weapon/",
    "title": "Many small models -- the Secret Weapon",
    "description": "how to fit and visualize small multiples",
    "author": [
      {
        "name": "Allen and Andrew",
        "url": {}
      }
    ],
    "date": "2022-06-10",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-06-10T13:56:59-04:00",
    "input_file": "many-small-models-the-secret-weapon.knit.md"
  },
  {
    "path": "posts/2022-06-06-hybrid-fly-life-history/",
    "title": "Hybrid fly life history",
    "description": "A short description of the post.",
    "author": [
      {
        "name": "Allen and Andrew",
        "url": {}
      }
    ],
    "date": "2022-06-06",
    "categories": [],
    "contents": "\r\nstudying the gamma\r\ndistribution\r\n\\[\r\n\\text{Gamma}(a, b)\r\n\\]\r\n\\[\r\n\\begin{align}\r\n\\mu = a/b \\\\\r\n\\sigma^2 = a/b^2\r\n\\end{align}\r\n\\]\r\n\\[\r\n\\text{Gamma}\\left(\\frac{\\mu^2}{\\sigma^2}, \\frac{\\mu}{\\sigma^2}\\right)\r\n\\]\r\n\\[\r\n\\text{Gamma}(\\mu b, b)\r\n\\]\r\n\\[\r\n\\text{Gamma}\\left(a, \\frac{a}{\\mu}\\right)\r\n\\]\r\n\r\n\r\ngamma_var <- rgamma(n = 570, shape = 6, scale = 1.5)\r\n\r\ngamma_var |> mean()\r\n\r\n\r\n[1] 8.832955\r\n\r\ngamma_var |> sd()\r\n\r\n\r\n[1] 3.483813\r\n\r\n# theoretical average\r\n6*1.5\r\n\r\n\r\n[1] 9\r\n\r\n# theory sd\r\nsqrt(6*1.5^2)\r\n\r\n\r\n[1] 3.674235\r\n\r\nsee the brms\r\nvignettes\r\nbrms uses mean \\(\\mu\\) rate = \\(\\alpha/\\mu\\)\r\n\r\n\r\na <- 3\r\nm <- 16\r\nxx <- rgamma(571, shape = m^2/a^2, rate = m/a^2)\r\nhist(xx)\r\n\r\n\r\n\r\nmean(xx)\r\n\r\n\r\n[1] 16.06514\r\n\r\nsd(xx)\r\n\r\n\r\n[1] 2.97064\r\n\r\n# could also define beta = mean/variance\r\nbeta <- m/a^2\r\nbeta\r\n\r\n\r\n[1] 1.777778\r\n\r\nxx2 <- rgamma(571, shape = m*beta, rate = beta)\r\nmean(xx2)\r\n\r\n\r\n[1] 15.85432\r\n\r\nsd(xx2)\r\n\r\n\r\n[1] 3.048394\r\n\r\n\r\n\r\nlibrary(brms)\r\n\r\ngamma_form <- bf(xx ~ 1,\r\n                 family = brmsfamily(\"Gamma\",\r\n                                     link = \"log\",\r\n                                     link_shape = \"log\")) + \r\n  lf(shape ~ 1)\r\n\r\nsimple_gamma <- brm(gamma_form, \r\n                    data = data.frame(xx), \r\n                    backend = \"cmdstanr\", cores = 4)\r\n\r\n\r\nRunning MCMC with 4 parallel chains...\r\n\r\nChain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \r\nChain 3 Iteration:    1 / 2000 [  0%]  (Warmup) \r\nChain 4 Iteration:    1 / 2000 [  0%]  (Warmup) \r\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \r\nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \r\nChain 2 Iteration:  100 / 2000 [  5%]  (Warmup) \r\nChain 3 Iteration:  100 / 2000 [  5%]  (Warmup) \r\nChain 4 Iteration:  100 / 2000 [  5%]  (Warmup) \r\nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \r\nChain 4 Iteration:  200 / 2000 [ 10%]  (Warmup) \r\nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \r\nChain 2 Iteration:  200 / 2000 [ 10%]  (Warmup) \r\nChain 3 Iteration:  200 / 2000 [ 10%]  (Warmup) \r\nChain 2 Iteration:  300 / 2000 [ 15%]  (Warmup) \r\nChain 4 Iteration:  300 / 2000 [ 15%]  (Warmup) \r\nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \r\nChain 3 Iteration:  300 / 2000 [ 15%]  (Warmup) \r\nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \r\nChain 2 Iteration:  400 / 2000 [ 20%]  (Warmup) \r\nChain 4 Iteration:  400 / 2000 [ 20%]  (Warmup) \r\nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \r\nChain 2 Iteration:  500 / 2000 [ 25%]  (Warmup) \r\nChain 3 Iteration:  400 / 2000 [ 20%]  (Warmup) \r\nChain 4 Iteration:  500 / 2000 [ 25%]  (Warmup) \r\nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \r\nChain 2 Iteration:  600 / 2000 [ 30%]  (Warmup) \r\nChain 3 Iteration:  500 / 2000 [ 25%]  (Warmup) \r\nChain 4 Iteration:  600 / 2000 [ 30%]  (Warmup) \r\nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \r\nChain 2 Iteration:  700 / 2000 [ 35%]  (Warmup) \r\nChain 3 Iteration:  600 / 2000 [ 30%]  (Warmup) \r\nChain 4 Iteration:  700 / 2000 [ 35%]  (Warmup) \r\nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \r\nChain 2 Iteration:  800 / 2000 [ 40%]  (Warmup) \r\nChain 3 Iteration:  700 / 2000 [ 35%]  (Warmup) \r\nChain 4 Iteration:  800 / 2000 [ 40%]  (Warmup) \r\nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \r\nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \r\nChain 2 Iteration:  900 / 2000 [ 45%]  (Warmup) \r\nChain 3 Iteration:  800 / 2000 [ 40%]  (Warmup) \r\nChain 4 Iteration:  900 / 2000 [ 45%]  (Warmup) \r\nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \r\nChain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \r\nChain 3 Iteration:  900 / 2000 [ 45%]  (Warmup) \r\nChain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup) \r\nChain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \r\nChain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling) \r\nChain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup) \r\nChain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling) \r\nChain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling) \r\nChain 4 Iteration: 1100 / 2000 [ 55%]  (Sampling) \r\nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \r\nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \r\nChain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling) \r\nChain 3 Iteration: 1100 / 2000 [ 55%]  (Sampling) \r\nChain 4 Iteration: 1200 / 2000 [ 60%]  (Sampling) \r\nChain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling) \r\nChain 4 Iteration: 1300 / 2000 [ 65%]  (Sampling) \r\nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \r\nChain 3 Iteration: 1200 / 2000 [ 60%]  (Sampling) \r\nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \r\nChain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling) \r\nChain 4 Iteration: 1400 / 2000 [ 70%]  (Sampling) \r\nChain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling) \r\nChain 3 Iteration: 1300 / 2000 [ 65%]  (Sampling) \r\nChain 4 Iteration: 1500 / 2000 [ 75%]  (Sampling) \r\nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \r\nChain 3 Iteration: 1400 / 2000 [ 70%]  (Sampling) \r\nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \r\nChain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling) \r\nChain 4 Iteration: 1600 / 2000 [ 80%]  (Sampling) \r\nChain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling) \r\nChain 3 Iteration: 1500 / 2000 [ 75%]  (Sampling) \r\nChain 4 Iteration: 1700 / 2000 [ 85%]  (Sampling) \r\nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \r\nChain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling) \r\nChain 3 Iteration: 1600 / 2000 [ 80%]  (Sampling) \r\nChain 4 Iteration: 1800 / 2000 [ 90%]  (Sampling) \r\nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \r\nChain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling) \r\nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \r\nChain 3 Iteration: 1700 / 2000 [ 85%]  (Sampling) \r\nChain 4 Iteration: 1900 / 2000 [ 95%]  (Sampling) \r\nChain 1 finished in 3.4 seconds.\r\nChain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \r\nChain 3 Iteration: 1800 / 2000 [ 90%]  (Sampling) \r\nChain 4 Iteration: 2000 / 2000 [100%]  (Sampling) \r\nChain 2 finished in 3.4 seconds.\r\nChain 4 finished in 3.5 seconds.\r\nChain 3 Iteration: 1900 / 2000 [ 95%]  (Sampling) \r\nChain 3 Iteration: 2000 / 2000 [100%]  (Sampling) \r\nChain 3 finished in 3.8 seconds.\r\n\r\nAll 4 chains finished successfully.\r\nMean chain execution time: 3.5 seconds.\r\nTotal execution time: 4.1 seconds.\r\n\r\nsummary(simple_gamma)\r\n\r\n\r\n Family: gamma \r\n  Links: mu = log; shape = log \r\nFormula: xx ~ 1 \r\n         shape ~ 1\r\n   Data: data.frame(xx) (Number of observations: 571) \r\n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\r\n         total post-warmup draws = 4000\r\n\r\nPopulation-Level Effects: \r\n                Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS\r\nIntercept           2.78      0.01     2.76     2.79 1.00     3329\r\nshape_Intercept     3.36      0.06     3.24     3.46 1.00     2742\r\n                Tail_ESS\r\nIntercept           2607\r\nshape_Intercept     2538\r\n\r\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\r\nand Tail_ESS are effective sample size measures, and Rhat is the potential\r\nscale reduction factor on split chains (at convergence, Rhat = 1).\r\n\r\nstancode(simple_gamma)\r\n\r\n\r\n// generated with brms 2.16.6\r\nfunctions {\r\n}\r\ndata {\r\n  int<lower=1> N;  // total number of observations\r\n  vector[N] Y;  // response variable\r\n  int prior_only;  // should the likelihood be ignored?\r\n}\r\ntransformed data {\r\n}\r\nparameters {\r\n  real Intercept;  // temporary intercept for centered predictors\r\n  real Intercept_shape;  // temporary intercept for centered predictors\r\n}\r\ntransformed parameters {\r\n  real lprior = 0;  // prior contributions to the log posterior\r\n  lprior += student_t_lpdf(Intercept | 3, 2.8, 2.5);\r\n  lprior += student_t_lpdf(Intercept_shape | 3, 0, 2.5);\r\n}\r\nmodel {\r\n  // likelihood including constants\r\n  if (!prior_only) {\r\n    // initialize linear predictor term\r\n    vector[N] mu = Intercept + rep_vector(0.0, N);\r\n    // initialize linear predictor term\r\n    vector[N] shape = Intercept_shape + rep_vector(0.0, N);\r\n    for (n in 1:N) {\r\n      // apply the inverse link function\r\n      shape[n] = exp(shape[n]);\r\n    }\r\n    for (n in 1:N) {\r\n      // apply the inverse link function\r\n      mu[n] = shape[n] * exp(-(mu[n]));\r\n    }\r\n    target += gamma_lpdf(Y | shape, mu);\r\n  }\r\n  // priors including constants\r\n  target += lprior;\r\n}\r\ngenerated quantities {\r\n  // actual population-level intercept\r\n  real b_Intercept = Intercept;\r\n  // actual population-level intercept\r\n  real b_shape_Intercept = Intercept_shape;\r\n}\r\n\r\nANdrew is going to ask in the Stan forum WTF is happening when you\r\nuse the gamma family – why does LF behave differently thank the\r\nalternative\r\n\r\n\r\nlibrary(tidybayes)\r\n\r\nsimple_gamma |> get_variables()\r\n\r\n\r\n [1] \"b_Intercept\"       \"b_shape_Intercept\" \"Intercept\"        \r\n [4] \"Intercept_shape\"   \"lprior\"            \"lp__\"             \r\n [7] \"accept_stat__\"     \"treedepth__\"       \"stepsize__\"       \r\n[10] \"divergent__\"       \"n_leapfrog__\"      \"energy__\"         \r\n\r\n# gather_draws(simple_gamma, b_Intercept, b_shape_Intercept)\r\n\r\ngather_rvars(simple_gamma, b_Intercept, b_shape_Intercept) |> \r\n  mutate(.value = exp(.value),\r\n         true_vals =  c(m, m^2/a^2)) |> \r\n  ggplot(aes(y = .variable, dist = .value))  + \r\n  stat_dist_dots() + \r\n  facet_wrap(~.variable, scales = \"free\") + \r\n  geom_vline(aes(xintercept = true_vals))\r\n\r\n\r\n\r\n\r\n\r\n\r\n## the Stan and brms parameterization of gamma translates into R like this: \r\n\r\nmean <- 42\r\nshape <- 2\r\n\r\nrr <- rgamma(300, shape, shape/mean)\r\n\r\n\r\nrr |> mean()\r\n\r\n\r\n[1] 40.90638\r\n\r\nrr |> sd()\r\n\r\n\r\n[1] 29.439\r\n\r\nrr |> var()\r\n\r\n\r\n[1] 866.6545\r\n\r\n42^2/2\r\n\r\n\r\n[1] 882\r\n\r\ngamma_form <- bf(xx ~ 1,\r\n                 family = brmsfamily(\"Gamma\",\r\n                                     link = \"identity\",\r\n                                     link_shape = \"identity\")) + \r\n  lf(shape ~ 1)\r\n\r\nmake_stancode(gamma_form, data = data.frame(xx))\r\n\r\n\r\n// generated with brms 2.16.6\r\nfunctions {\r\n}\r\ndata {\r\n  int<lower=1> N;  // total number of observations\r\n  vector[N] Y;  // response variable\r\n  int prior_only;  // should the likelihood be ignored?\r\n}\r\ntransformed data {\r\n}\r\nparameters {\r\n  real Intercept;  // temporary intercept for centered predictors\r\n  real Intercept_shape;  // temporary intercept for centered predictors\r\n}\r\ntransformed parameters {\r\n  real lprior = 0;  // prior contributions to the log posterior\r\n  lprior += student_t_lpdf(Intercept | 3, 15.9, 2.8);\r\n  lprior += gamma_lpdf(Intercept_shape | 0.01, 0.01);\r\n}\r\nmodel {\r\n  // likelihood including constants\r\n  if (!prior_only) {\r\n    // initialize linear predictor term\r\n    vector[N] mu = Intercept + rep_vector(0.0, N);\r\n    // initialize linear predictor term\r\n    vector[N] shape = Intercept_shape + rep_vector(0.0, N);\r\n    for (n in 1:N) {\r\n      // apply the inverse link function\r\n      mu[n] = shape[n] / (mu[n]);\r\n    }\r\n    target += gamma_lpdf(Y | shape, mu);\r\n  }\r\n  // priors including constants\r\n  target += lprior;\r\n}\r\ngenerated quantities {\r\n  // actual population-level intercept\r\n  real b_Intercept = Intercept;\r\n  // actual population-level intercept\r\n  real b_shape_Intercept = Intercept_shape;\r\n}\r\n\r\n\r\n\r\n# stancode(simple_gamma)\r\n\r\n\r\n\r\nprior simulations\r\n\r\n\r\nget_prior(gamma_form, data = data.frame(xx))\r\n\r\n\r\n                   prior     class coef group resp  dpar nlpar bound\r\n student_t(3, 15.9, 2.8) Intercept                                  \r\n       gamma(0.01, 0.01) Intercept                 shape            \r\n  source\r\n default\r\n default\r\n\r\nandrew_prior <- c(prior(normal(2, .3), class = \"Intercept\"),\r\n                  prior(normal(2, .4), class = \"Intercept\", dpar = \"shape\"))\r\n\r\n\r\n\r\n\r\n\r\n# visualizing in base R \r\n\r\nrnorm(4000, mean = 2, sd = .2) |> exp() |> hist()\r\n\r\n\r\n\r\n\r\n\r\n\r\ngamma_form <- bf(xx ~ 1,\r\n                 family = brmsfamily(\"Gamma\",\r\n                                     link = \"log\",\r\n                                     link_shape = \"log\")) + \r\n  lf(shape ~ 1)\r\n\r\ngamma_prior_predict <- brm(gamma_form, data = data.frame(xx), \r\n    prior = andrew_prior,\r\n    backend = \"cmdstanr\", cores = 4, sample_prior = \"only\")\r\n\r\n# visualize\r\ngamma_prior_predict |> \r\n  gather_draws( b_Intercept, b_shape_Intercept, ndraws = 6)\r\n\r\ndata.frame(nn = 1:450) |> \r\n  add_predicted_draws(gamma_prior_predict, ndraws = 12) |> \r\n  ggplot(aes(x = .prediction)) + \r\n  geom_histogram() + \r\n  facet_wrap(~.draw, ncol = 4)\r\n\r\n\r\n\r\nexperimental design\r\nH, N, and hybrid – three kinds of flies\r\nis development time different among the three lines? Does the\r\nvariance in development time differ between the lines?\r\nbegin by modelling one fly species, one life history stage\r\nusing the brms parameterization\r\n\r\n\r\n# larval development times\r\nhist(rgamma(570, shape = 30, rate = 30/12))\r\n\r\n\r\n\r\n# pupal development times\r\nhist(rgamma(570, shape = 30, rate = 30/13))\r\n\r\n\r\n\r\n\r\n\r\n\r\ngamma_form <- bf(xx ~ 1,\r\n                 family = brmsfamily(\"Gamma\",\r\n                                     link = \"log\",\r\n                                     link_shape = \"log\")) + \r\n  lf(shape ~ 1)\r\n\r\nsimple_gamma <- brm(gamma_form, \r\n                    data = data.frame(xx = rgamma(570,\r\n                                                  shape = 30,\r\n                                                  rate = 30/13)),\r\n                    here::here(\"_posts\", \r\n                               \"2022-06-06-hybrid-fly-life-history\",\r\n                               \"simple_gamma.rds\"),\r\n                    backend = \"cmdstanr\", cores = 4)\r\n\r\n\r\nRunning MCMC with 4 parallel chains...\r\n\r\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \r\nChain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \r\nChain 3 Iteration:    1 / 2000 [  0%]  (Warmup) \r\nChain 4 Iteration:    1 / 2000 [  0%]  (Warmup) \r\nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \r\nChain 2 Iteration:  100 / 2000 [  5%]  (Warmup) \r\nChain 3 Iteration:  100 / 2000 [  5%]  (Warmup) \r\nChain 4 Iteration:  100 / 2000 [  5%]  (Warmup) \r\nChain 2 Iteration:  200 / 2000 [ 10%]  (Warmup) \r\nChain 3 Iteration:  200 / 2000 [ 10%]  (Warmup) \r\nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \r\nChain 4 Iteration:  200 / 2000 [ 10%]  (Warmup) \r\nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \r\nChain 2 Iteration:  300 / 2000 [ 15%]  (Warmup) \r\nChain 3 Iteration:  300 / 2000 [ 15%]  (Warmup) \r\nChain 4 Iteration:  300 / 2000 [ 15%]  (Warmup) \r\nChain 2 Iteration:  400 / 2000 [ 20%]  (Warmup) \r\nChain 3 Iteration:  400 / 2000 [ 20%]  (Warmup) \r\nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \r\nChain 4 Iteration:  400 / 2000 [ 20%]  (Warmup) \r\nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \r\nChain 2 Iteration:  500 / 2000 [ 25%]  (Warmup) \r\nChain 3 Iteration:  500 / 2000 [ 25%]  (Warmup) \r\nChain 2 Iteration:  600 / 2000 [ 30%]  (Warmup) \r\nChain 3 Iteration:  600 / 2000 [ 30%]  (Warmup) \r\nChain 4 Iteration:  500 / 2000 [ 25%]  (Warmup) \r\nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \r\nChain 3 Iteration:  700 / 2000 [ 35%]  (Warmup) \r\nChain 4 Iteration:  600 / 2000 [ 30%]  (Warmup) \r\nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \r\nChain 2 Iteration:  700 / 2000 [ 35%]  (Warmup) \r\nChain 3 Iteration:  800 / 2000 [ 40%]  (Warmup) \r\nChain 4 Iteration:  700 / 2000 [ 35%]  (Warmup) \r\nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \r\nChain 2 Iteration:  800 / 2000 [ 40%]  (Warmup) \r\nChain 3 Iteration:  900 / 2000 [ 45%]  (Warmup) \r\nChain 4 Iteration:  800 / 2000 [ 40%]  (Warmup) \r\nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \r\nChain 2 Iteration:  900 / 2000 [ 45%]  (Warmup) \r\nChain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \r\nChain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \r\nChain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup) \r\nChain 4 Iteration:  900 / 2000 [ 45%]  (Warmup) \r\nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \r\nChain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling) \r\nChain 3 Iteration: 1100 / 2000 [ 55%]  (Sampling) \r\nChain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup) \r\nChain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling) \r\nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \r\nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \r\nChain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling) \r\nChain 3 Iteration: 1200 / 2000 [ 60%]  (Sampling) \r\nChain 4 Iteration: 1100 / 2000 [ 55%]  (Sampling) \r\nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \r\nChain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling) \r\nChain 3 Iteration: 1300 / 2000 [ 65%]  (Sampling) \r\nChain 4 Iteration: 1200 / 2000 [ 60%]  (Sampling) \r\nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \r\nChain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling) \r\nChain 3 Iteration: 1400 / 2000 [ 70%]  (Sampling) \r\nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \r\nChain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling) \r\nChain 3 Iteration: 1500 / 2000 [ 75%]  (Sampling) \r\nChain 4 Iteration: 1300 / 2000 [ 65%]  (Sampling) \r\nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \r\nChain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling) \r\nChain 4 Iteration: 1400 / 2000 [ 70%]  (Sampling) \r\nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \r\nChain 3 Iteration: 1600 / 2000 [ 80%]  (Sampling) \r\nChain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling) \r\nChain 3 Iteration: 1700 / 2000 [ 85%]  (Sampling) \r\nChain 4 Iteration: 1500 / 2000 [ 75%]  (Sampling) \r\nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \r\nChain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling) \r\nChain 3 Iteration: 1800 / 2000 [ 90%]  (Sampling) \r\nChain 4 Iteration: 1600 / 2000 [ 80%]  (Sampling) \r\nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \r\nChain 3 Iteration: 1900 / 2000 [ 95%]  (Sampling) \r\nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \r\nChain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling) \r\nChain 4 Iteration: 1700 / 2000 [ 85%]  (Sampling) \r\nChain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling) \r\nChain 3 Iteration: 2000 / 2000 [100%]  (Sampling) \r\nChain 4 Iteration: 1800 / 2000 [ 90%]  (Sampling) \r\nChain 3 finished in 3.1 seconds.\r\nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \r\nChain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \r\nChain 4 Iteration: 1900 / 2000 [ 95%]  (Sampling) \r\nChain 1 finished in 3.2 seconds.\r\nChain 2 finished in 3.3 seconds.\r\nChain 4 Iteration: 2000 / 2000 [100%]  (Sampling) \r\nChain 4 finished in 3.4 seconds.\r\n\r\nAll 4 chains finished successfully.\r\nMean chain execution time: 3.2 seconds.\r\nTotal execution time: 3.7 seconds.\r\n\r\nsimple_gamma |> \r\n  gather_rvars(Intercept, Intercept_shape) |> \r\n  mutate(.value = exp(.value)) |> \r\n  ggplot(aes(y = .variable, dist = .value)) + \r\n  stat_dist_halfeye()\r\n\r\n\r\n\r\n\r\nduration and variance are approximately (but not necessarily)\r\nequal\r\nStart with: many individuals all with the same expected duration of\r\neach life history stage.\r\ncorrelated both stages\r\n\r\n\r\ncorr_larva_pupa <- .8\r\n\r\ncorr_mat <- matrix(c(1, corr_larva_pupa,\r\n                     corr_larva_pupa, 1), byrow = TRUE, ncol = 2)\r\n\r\nlarv_sd <- .5\r\npupa_sd <- .7\r\n\r\nsds <- c(larv_sd, pupa_sd)\r\n\r\nSigma <- diag(sds) %*% corr_mat %*% diag(sds)\r\n\r\nlarv_pupa <- MASS::mvrnorm(570, mu = c(13, 13), Sigma = Sigma)\r\n\r\nplot(larv_pupa[,1], larv_pupa[,2])\r\n\r\n\r\n\r\n\r\nAdd observation variance\r\n\r\n\r\ntrue_shape <- 70\r\n\r\nfake_development_times <- tibble(fly_id = 1:570,\r\n       fly_code = paste0(\"fly\", fly_id)) |> \r\n  mutate(avg_larva = larv_pupa[fly_id, 1],\r\n         avg_pupae = larv_pupa[fly_id, 2]) |> \r\n  rowwise() |> \r\n  mutate(\r\n    # add observation variance\r\n    obs_larva = rgamma(1, shape = true_shape, rate = true_shape/avg_larva),\r\n    obs_pupae = rgamma(1, shape = true_shape, rate = true_shape/avg_pupae)\r\n  )\r\n\r\n\r\n\r\nplot, then model\r\n\r\n\r\nfake_development_times |> \r\n  ggplot(aes(x = obs_larva, y = obs_pupae)) + geom_point()\r\n\r\n\r\n\r\nfake_development_times |> \r\n  ggplot(aes(x = avg_larva, y = avg_pupae)) + geom_point()\r\n\r\n\r\n\r\n\r\ncorrelation is hard to see under the gamma errors!\r\nlet’s see if a model can recover that\r\n\r\n\r\nfake_devo_long <- fake_development_times |> \r\n  select(-starts_with(\"avg\")) |> \r\n  pivot_longer(starts_with(\"obs\"),\r\n               names_to = \"stage\",\r\n               values_to = \"days\")\r\n\r\n\r\ngamma_form_correlated_stages <- bf(days ~ stage + (1 + stage | fly_code),\r\n                 family = brmsfamily(\"Gamma\",\r\n                                     link = \"log\",\r\n                                     link_shape = \"log\")) + \r\n  lf(shape ~ 1)\r\n\r\n\r\nget_prior(gamma_form_correlated_stages, data = fake_devo_long)\r\n\r\n\r\n                  prior     class           coef    group resp  dpar\r\n                 (flat)         b                                   \r\n                 (flat)         b stageobs_pupae                    \r\n                 lkj(1)       cor                                   \r\n                 lkj(1)       cor                fly_code           \r\n student_t(3, 2.6, 2.5) Intercept                                   \r\n   student_t(3, 0, 2.5)        sd                                   \r\n   student_t(3, 0, 2.5)        sd                fly_code           \r\n   student_t(3, 0, 2.5)        sd      Intercept fly_code           \r\n   student_t(3, 0, 2.5)        sd stageobs_pupae fly_code           \r\n   student_t(3, 0, 2.5) Intercept                              shape\r\n nlpar bound       source\r\n                  default\r\n             (vectorized)\r\n                  default\r\n             (vectorized)\r\n                  default\r\n                  default\r\n             (vectorized)\r\n             (vectorized)\r\n             (vectorized)\r\n                  default\r\n\r\ncorr_stages_priors <- c(\r\n  prior(normal(0,1), class = \"b\"),\r\n  prior(lkj(2), class = \"cor\"),\r\n  prior(normal(2.5,1), class = \"Intercept\"),\r\n  prior(exponential(2), class = \"sd\"),\r\n  prior(normal(4,2), class = \"Intercept\", dpar = \"shape\")\r\n)\r\n\r\n\r\ncorrelated_stages_gamma <- brm(gamma_form_correlated_stages,\r\n                               data = fake_devo_long, \r\n                               prior = corr_stages_priors,\r\n                               file = here::here(\"_posts\", \"2022-06-06-hybrid-fly-life-history\", \"corr_gamma.rds\"),\r\n                               cores = 4)\r\n\r\ncorrelated_stages_gamma\r\n\r\n\r\n Family: gamma \r\n  Links: mu = log; shape = log \r\nFormula: days ~ stage + (1 + stage | fly_code) \r\n         shape ~ 1\r\n   Data: fake_devo_long (Number of observations: 1140) \r\n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\r\n         total post-warmup draws = 4000\r\n\r\nGroup-Level Effects: \r\n~fly_code (Number of levels: 570) \r\n                              Estimate Est.Error l-95% CI u-95% CI\r\nsd(Intercept)                     0.04      0.01     0.01     0.06\r\nsd(stageobs_pupae)                0.03      0.02     0.00     0.07\r\ncor(Intercept,stageobs_pupae)    -0.04      0.41    -0.73     0.77\r\n                              Rhat Bulk_ESS Tail_ESS\r\nsd(Intercept)                 1.01      292      565\r\nsd(stageobs_pupae)            1.02      245      286\r\ncor(Intercept,stageobs_pupae) 1.00      982     2074\r\n\r\nPopulation-Level Effects: \r\n                Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS\r\nIntercept           2.56      0.01     2.55     2.57 1.00     3898\r\nshape_Intercept     4.20      0.07     4.06     4.35 1.01      345\r\nstageobs_pupae      0.01      0.01    -0.01     0.02 1.00     2033\r\n                Tail_ESS\r\nIntercept           2312\r\nshape_Intercept      415\r\nstageobs_pupae       613\r\n\r\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\r\nand Tail_ESS are effective sample size measures, and Rhat is the potential\r\nscale reduction factor on split chains (at convergence, Rhat = 1).\r\n\r\nMaybe a simpler model (the above seems overparameterized) where each\r\nlarva has a single offset (e.g. proportional to “quality” or “resource\r\nuse efficiency”).\r\n\r\n\r\nnfly <- 570\r\n# average time you spend as a larva\r\nlog_avg_larva_time <-  log(13)\r\n# average time DIFFERECE to the time you spend as a pupa (might be close to 0)\r\nlog_to_pupa <- -.2\r\n# your \"quality\", some idea of how much above and below the population you are\r\nlog_indiv_quality <- rnorm(n = nfly, mean = 0, sd = .2)\r\n\r\nexp(log_avg_larva_time)\r\n\r\n\r\n[1] 13\r\n\r\nexp(log_avg_larva_time + log_to_pupa)\r\n\r\n\r\n[1] 10.6435\r\n\r\nfake_flies_intercept <- tibble(\r\n  fly_id = 1:570,\r\n  fly_code = paste0(\"fly\", fly_id)\r\n) |> \r\n  rowwise() |> \r\n  mutate(lh = list(data.frame(stage_id = c(0,1),\r\n                              stage_nm = c(\"larv\", \"pupa\"))))\r\n\r\ntrue_shape_intercept <- 72\r\n\r\nfake_intercept_obs <- fake_flies_intercept |> \r\n  unnest(cols = c(\"lh\")) |> \r\n  mutate(avg_duration = log_avg_larva_time + log_to_pupa*stage_id,\r\n         ecart_indiv = log_indiv_quality[fly_id],\r\n         fly_duration = avg_duration + ecart_indiv) |> \r\n  rowwise() |> \r\n  mutate(obs_duration = rgamma(1, true_shape_intercept, rate = true_shape_intercept/exp(fly_duration)))\r\n\r\nfake_intercept_obs |> \r\n  ggplot(aes(x = obs_duration, fill = stage_nm)) + geom_histogram()\r\n\r\n\r\n\r\n\r\n\r\n\r\nfake_intercept_obs |> \r\n  select(fly_id, stage_nm, obs_duration) |> \r\n  ungroup() |> \r\n  pivot_wider(names_from = stage_nm, values_from = obs_duration) |> \r\n  ggplot(aes(x = larv, y = pupa)) + geom_point()\r\n\r\n\r\n\r\n\r\nmodel to recover\r\n\r\n\r\ngamma_form_intercept <- bf(obs_duration ~ stage_nm + (1| fly_code),\r\n                                   family = brmsfamily(\"Gamma\",\r\n                                                       link = \"log\",\r\n                                                       link_shape = \"log\")) + \r\n  lf(shape ~ 1)\r\n\r\n\r\nget_prior(gamma_form_intercept, data = fake_intercept_obs)\r\n\r\n\r\n                  prior     class         coef    group resp  dpar\r\n                 (flat)         b                                 \r\n                 (flat)         b stage_nmpupa                    \r\n student_t(3, 2.4, 2.5) Intercept                                 \r\n   student_t(3, 0, 2.5)        sd                                 \r\n   student_t(3, 0, 2.5)        sd              fly_code           \r\n   student_t(3, 0, 2.5)        sd    Intercept fly_code           \r\n   student_t(3, 0, 2.5) Intercept                            shape\r\n nlpar bound       source\r\n                  default\r\n             (vectorized)\r\n                  default\r\n                  default\r\n             (vectorized)\r\n             (vectorized)\r\n                  default\r\n\r\nintercept_priors <- c(\r\n  prior(normal(0,1), class = \"b\"),\r\n  prior(normal(2.5,1), class = \"Intercept\"),\r\n  prior(exponential(2), class = \"sd\"),\r\n  prior(normal(4,2), class = \"Intercept\", dpar = \"shape\")\r\n)\r\n\r\n\r\nintercept_stages_gamma <- brm(gamma_form_intercept,\r\n                               data = fake_intercept_obs, \r\n                               prior = intercept_priors,\r\n                               file = here::here(\"_posts\", \"2022-06-06-hybrid-fly-life-history\", \"intercept_gamma.rds\"),\r\n                               cores = 4)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-06-hybrid-fly-life-history/hybrid-fly-life-history_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2022-06-06T12:31:25-04:00",
    "input_file": "hybrid-fly-life-history.knit.md"
  },
  {
    "path": "posts/2022-05-26-fid-when-to-run-away/",
    "title": "FID: When to run away",
    "description": "Modelling a decay to a constant",
    "author": [
      {
        "name": "Nora Jones",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2022-05-26",
    "categories": [],
    "contents": "\r\n\\[\r\n\\begin{align}\r\n\\text{FID}_{crj} \\sim& \\text{Gamma}\\left(\\frac{\\mu_{cr}}{\\sigma^2}, \\frac{\\mu_{cr}^2}{\\sigma^2}\\right)\\\\\r\n\\mu_{cr} =& m_{cr} \\times 1000 \\times \\left( 1 - \\frac{p_{cr} \\times X_j}{d_{cr} + X_j}  \\right) \\\\\r\n\\text{logit}(m_{cr}) =& \\bar{m} + \\beta_{m,r} + m_{c,r}\\\\\r\n\\text{logit}(p_{cr}) =& \\bar{p} + \\beta_{p,r} + p_{c,r}\\\\\r\n\\text{log}(d_{cr})   =& \\bar{d} + \\beta_{d,r} + d_{c,r}\\\\\r\n\\begin{bmatrix}\r\nm_{r}\\\\\r\np_{r}\\\\\r\nd_{r}\r\n\\end{bmatrix} &\\sim \\text{MVnormal}\\left(\\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}, \\textbf{S}_{r}\\right)\r\n\\end{align}\r\n\\]\r\n\\[\r\n\\begin{align}\r\n\\text{FID}_i \\sim& \\text{Gamma}\\left(\\frac{\\mu_i}{\\sigma^2}, \\frac{\\mu_i^2}{\\sigma^2}\\right)\\\\\r\n\\mu_i =& m_i \\times 1000 \\times \\left( 1 - \\frac{p_i \\times \\text{Obs}}{d_i + \\text{Obs}}  \\right) \\\\\r\n\\text{logit}(m_i) =& \\bar{m} + \\beta_{m,\\text{risk}[i]} + m_{\\text{tamia}[i], \\text{risk}[i]}\\\\\r\n\\text{logit}(p_i) =& \\bar{p} + \\beta_{p,\\text{risk}[i]} + p_{\\text{tamia}[i], \\text{risk}[i]}\\\\\r\n\\text{log}(d_i)   =& \\bar{d} + \\beta_{d,\\text{risk}[i]} + d_{\\text{tamia}[i], \\text{risk}[i]}\\\\\r\n\\begin{bmatrix}\r\nm_{\\text{tamia}, \\text{risk}[i]}\\\\\r\np_{\\text{tamia}, \\text{risk}[i]}\\\\\r\nd_{\\text{tamia}, \\text{risk}[i]}\r\n\\end{bmatrix} &\\sim \\text{MVnormal}\\left(\\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}, \\textbf{S}_{\\text{risk}[i]}\\right)\r\n\\end{align}\r\n\\]\r\n\\(j\\) indicates the chipmunks present in each treatment, of which there are \\(J_r\\)\r\nput real numbers in? why not?\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-05-26-fid-when-to-run-away/fid-when-to-run-away_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2022-06-06T09:54:34-04:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to Simulation of Ecological Data",
    "description": "Welcome to our new blog, Simulation of Ecological Data. We hope you enjoy \nreading what we have to say!",
    "author": [
      {
        "name": "Nora Jones",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2022-05-26",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-06-06T09:54:34-04:00",
    "input_file": {}
  }
]
