---
title: "Intercept only poisson example"
description: |
  Where do counts vary the most?.
author:
  - name: Andrew and Will
    url: {}
date: 2022-08-04
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


$$
\begin{align}
\text{recruits} \sim& \text{Poisson}(\lambda) \\
\lambda =& \beta_0 + \beta_{spp} + \beta_{plot} + \beta_{year} + \ln(\text{Area}) \\
\beta_{spp} \sim& \text{normal}(0, \sigma_{spp})\\
\beta_{plot} \sim& \text{normal}(0, \sigma_{plot})\\
\beta_{year} \sim& \text{normal}(0, \sigma_{year})\\
\sigma_{spp} , \sigma_{plot}, \sigma_{year} \sim&
\text{exponential}(1)\\
\beta_0\sim&\text{normal}(3,1)\\
\end{align}
$$

Simulations! 

```{r}
nspp <- 10
nplot <- 5
nyear <- 40

avg <- log(2.3) # how many on average per square meter

betaspp <- rnorm(nspp, 0, 2)
betaplot <- rnorm(nplot, 0, .2)
betyear <- rnorm(nyear, 0, 1)

# intervals for each plot:
deltayears <- sample(c(5, 10, 13),size=nplot, replace = TRUE)

library(tidyverse)


```

## a simple stan program

```{r}
library(here)
library(cmdstanr)
poisson_model <- cmdstan_model(stan_file = here::here("_posts/2022-08-04-intercept-only-poisson-example/poisson_intercept_only.stan"),
                               pedantic = TRUE)

```


```{r}

```


### side note -- survivorship every year

an average of $\lambda$ seedlings grow every year and $p$ survive to the next generation

The number surviving after t years is 

$$
\begin{align}
p^t \times \lambda
\end{align}
$$


which is another, smaller poisson distribution. 

What happens if you keep adding more individuals? every year you add on average $\lambda$ new individuals who survive as described above. 

so if that happens every year for $t$ years then you have 

$$
\left(\sum_{i = 0}^t p^i\right) \times \lambda
$$

So every year we get on average $\lambda$ new recruits and they have to survive up to the present to get counted.

$$
\begin{align}
\text{recruits} &= \left(\sum_{i = 0}^t p^i\right) \times \lambda \\
&=  \lambda \frac{1 - p^{t+1}}{1 - p} \\
\end{align}
$$


Is that correct? let's see with a simulation!

```{r}

library(tidyverse)

# simulate just one cohort
# "years" is delta-t
make_surviving_vec <- function(years, lambda, psurv){
  
  # how many survive each year -- 
  # include the CURRENT year (so for 3 years we have 3 spaces: t0, t1, t2)
  surviving <- numeric(years)
  starting <- rpois(n = 1, lambda =lambda)
  surviving[1] <- starting
  
  if(years > 0 )
    for(i in 1:years){
      surviving[i+1] <- rbinom(n = 1, prob = psurv, size = surviving[i])
    }
  
  return(surviving)
}



make_surviving_vec(5, 20, .92)

make_surviving_vec(2, 10, .3)

# so how many ultimately survive? -- just take the end of the vector

make_surviving_vec(15, 20, .92) |> tail(1)

### repeat this for every cohort produced in the t years:

all_cohorts_total <- function(year, ...){
  
  # how many survive to present from each cohort?
  each_cohort <- numeric(year+1)
  
  # for each year, simulate one surviving cohort
  # assuming that mortality has happend for this year! 
  for (y in 0:year){
    each_cohort[y+1] <- make_surviving_vec(y, ...) |> tail(1)
  }
  
  # return(each_year)
  
  total <- sum(each_cohort)

  return(total)
}
```

I want to demonstrate that these functions work as intended! 
At time $t=0$, an average of $\lambda$ trees are born but none have died yet. So the average surviving from a cohort should be $\lambda$

```{r surv-t0}
hist(replicate(1000, all_cohorts_total(0, lambda = 33, psurv = .7)))
abline(v = 33)
```

Meanwhile if one year passes, the cohort from last year has one chance to die. 
Now we should have $\lambda + p\lambda$ trees to look at:

```{r surv-t1}
hist(replicate(1000, all_cohorts_total(1, lambda = 33, psurv = .7)))
abline(v = 33*.7 + 33, lwd = 2, col = "red")
```

Finally, lets simulate many observations made of many plots, with increasingly long intervals between observations:

```{r math-sim-match}
# now do this for every year, and repeat the process:

p <- .8
lambda <- 30

curve_data <- tibble(t = 0:31) |> 
  rowwise() |> 
  mutate(surv = list(replicate(30, 
                               all_cohorts_total(t, lambda = lambda, psurv = p)))) |> 
  unnest(surv) 


curve_data |> 
  ggplot(aes(x = t, y = surv)) + 
  geom_count(alpha = .4, col = "darkgreen") + 
  stat_function(fun = \(x) (1 - p^(x+1))/(1 - p )*lambda, col = "orange", lwd = 2) + 
  theme_bw()

```

Looks encouraging! 

This is modelling the number of recruits made each year. Of course the distribution of individuals of EVERY size category is a balance of two processes. however for most large trees we have individual-level differences. 

It's important to know if we are modelling *number of new recruits* or simply the number of small trees. This is an expression for the former. But if it is the latter, then you would I guess let t go to infinity.  In this case the expression goes to:

$$
\text{recruits} = \lambda \times \frac{1}{1-p}
$$




